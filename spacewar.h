// Programming 2D Games
// Copyright (c) 2011 by: 
// Charles Kelly
// spacewar.h Scrolling Bitmap Demo

#ifndef _SPACEWAR_H             // Prevent multiple definitions if this 
#define _SPACEWAR_H             // file is included in more than one place
#define WIN32_LEAN_AND_MEAN

#include <string>
#include <list>
#include <vector>
#include <random>
#include <iostream>
#include <fstream>
#include "game.h"
#include "textureManager.h"
#include "image.h"
#include "ship.h"
#include "enemyShip.h"
#include "laser.h"
#include "asteroid.h"
#include "gravitationalBody.h"
#include "blackHole.h"
#include "missile.h"
#include "enemyMissileShip.h"
#include "powerUp.h"

namespace spacewarNS
{
    const char FONT[] = "Arial Bold";  // font
    const int FONT_BIG_SIZE = 256;     // font height
    const int FONT_SCORE_SIZE = 48;
    const COLOR_ARGB FONT_COLOR = graphicsNS::YELLOW;
    const COLOR_ARGB SHIP1_COLOR = graphicsNS::BLUE;
    const int SCORE_Y = 10;
    const int SCORE1_X = 60;
    const int HEALTHBAR_Y = 40;
    const int SHIP1_HEALTHBAR_X = 40;
    const int HEALTHBAR_START_FRAME = 22;
    const int HEALTHBAR_END_FRAME = 22;
    const int HEALTHBAR_HEIGHT = 32;
    const int HEALTHBAR_WIDTH = 64;
    const int COUNT_DOWN_X = GAME_WIDTH/2 - FONT_BIG_SIZE/4;
    const int COUNT_DOWN_Y = GAME_HEIGHT/2 - FONT_BIG_SIZE/2;
    const int COUNT_DOWN = 2;           // count down
    const int BUF_SIZE = 20;
    const int ROUND_TIME = 5;           // time until new round starts
    const int HEALTHBAR_TEXTURE_COLS = 4;   // health bar is a 4 column texture
	const float FIRE_DELAY = 0.5f;      // 1/2 a second between torpedo firing
	const float ASTEROID_TOTAL_DURATION = 20;	// number of seconds an asteroid field is allowed to persist
	const float ASTEROID_SPAWN_DELAY = 1.0f;      // 4 seconds between torpedo firing
	const float NATURAL_BLACK_HOLE_TOTAL_STAY_TIME = 50.0f;
	enum OBSTACLE {SHIPS, ASTEROIDS, PLANET};
	enum PLANET_OBSTACLE {PLANET_SHIPS};		// todo: add more obstacles later
	const float RUSH_TIMER_MAX = 10.0f;
	enum ENEMY_SPAWN_SIDE {LEFT, RIGHT};
	const float MAX_BLACK_HOLE_TIME = 4.0f;	// how long the black hole will stay before it goes away
	const short LEVELS_BEFORE_POWER_UP = 1;//5;
}

// Spacewar is the class we create, it inherits from the Game class
class Spacewar : public Game
{
private:
    // game items
    TextureManager menuTexture, spaceTexture, planetTexture, textures1, textures2, boss1Texture;   // textures
	std::vector<spacewarNS::OBSTACLE> worldSequence;
	std::vector<spacewarNS::PLANET_OBSTACLE> planetSequence;
    Ship    ship1;              // player spaceship
	std::list<EnemyShip*> enemyShips;	// enemy spaceships
    Image   space;              // backdrop image
	Image	planetSurface;				// backdrop image
    Image   menu;               // menu image
	Image	boss1;				// boss1 image
	GravitationalBody	planet;
	BlackHole	blackHole;
	PowerUp powerUp;
	//Asteroid	asteroid; // todo: remove this. For testing purposes
	std::list<Laser*> playerLasers;
	std::list<Entity*> enemyProjectiles;
	std::list<Asteroid*> asteroids;
    bool    menuOn;
    bool    countDownOn;        // true when count down is displayed
	bool	planetSurfaceMode;
    float   countDownTimer;
    TextDX  fontBig;            // DirectX font for game banners
    TextDX  fontScore;
    char buffer[spacewarNS::BUF_SIZE];
    bool    ship1Scored;        // true if ship scored during round
    bool    roundOver;          // true when round is over
    float   roundTimer;         // time until new round starts
    int     ship1Score; // scores
	float   fireTimer;                  // time remaining until fire enabled
	bool	asteroidsOn;
	float	asteroidDuration;
	float	asteroidSpawnTimer;
	size_t	obstacleInd;
	size_t	planetObstacleInd;
	bool nextWaveReady;
	spacewarNS::OBSTACLE currObstacle;
	spacewarNS::PLANET_OBSTACLE currPlanetObstacle;
	std::default_random_engine generator;
	std::uniform_int_distribution<int> distributionObstacle;
	std::uniform_int_distribution<int> distributionEnemySpawnLoc;
	ofstream myfile;
	float rushTimer;
	spacewarNS::ENEMY_SPAWN_SIDE enemySpawnSide, enemyMissileSpawnSide;
	float shipSpawnXLoc; // keeps track of where last ship was spawned off screen
	float blackHoleTimer; // keeps track of how long the black hole generated by the player will last

	void initializeLaser(Laser* aLaser, bool isPlayers = true);
	void initializeMissile(Missile* aMissile);
	void deleteDestroyedLasers();
	void deleteOutOfBoundsShips();
	void deleteAllLasers();
	void deleteOutOfBoundPowerUp();
	void initiateEnemyShips(short numShips);
	void initiateEnemyMissileShips(short numShips);
	void initiateAnAsteroid();
	void deleteAllEnemyShips();
	void deleteAllAsteroids();
	void initiatePlanet();
	void initiateBlackHole();
	void generateWorldSequence(short worldLength);
	void generatePlanetSequence(short planetSeqLength);
	spacewarNS::OBSTACLE generateRandomObstacle();
	spacewarNS::PLANET_OBSTACLE generateRandomPlanetObstacle();
	void wrapImage(Image&, const int, const int);
	void fillRestOfBackdrop(Image&, const int, const int);
	void findAndSetRushReadyShip();
	enemyShipNS::RUSH_DIR getRushDirection(EnemyShip*);
	void setAllEnemyShipRushDirection();

public:
    // Constructor
    Spacewar();
    // Destructor
    virtual ~Spacewar();
    // Initialize the game
    void initialize(HWND hwnd);
    void update();      // must override pure virtual from Game
    void ai();          // "
    void collisions();  // "
    void render();      // "
    void roundStart();  // start a new round of play
    void releaseAll();
    void resetAll();
};

#endif
